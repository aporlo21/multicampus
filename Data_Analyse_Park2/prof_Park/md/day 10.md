## day 10 

* 이미지 처리 = 진폭 주파수 지식 
* 샘플링 변환 // 푸리에 변환 
* // => 엣지 컴퓨팅 
* 길찾기 - 출발지 . 도착지 
* bfs / dfs 
* astar : 컴퓨터 게임 

- 책설명

갈색 - 이미지 처리

머신러낭 - 보라 / 주황

딥러닝 - 빨강

쉽다 - 벌집모양



* IOT

  아마존 AWS IoT
아마존은 데이터 분석을 중심으로 인공지능과 하드웨어의 결합을 통해 생태계를 구축해 나가고 있다.

  IBM 왓슨 IoT
IBM의 ‘왓슨 IoT’는 인공지능을 기반으로 IoT 기기를 통해 습득한 데이터를 분석하는 대표적인 데이터 분석 플랫폼이다. IBM은 빅데이터를 갖고 있거나 데이터 분석이 필요한 기업에게 왓슨 IoT 플랫폼을 제공하고, 기업들은 왓슨 IoT 플랫폼을 이용해 IoT 서비스를 제공하는 방식이다.
왓슨 IoT는 의료 산업에서의 데이터 분석에서 시작해 기계, 자동차, 물류, 보안, 금융, 로봇 등 다양한 산업으로 확대 적용하고 있다.



* end to end

 지금까지 모니터링의 주요 방식은 수동적 관찰(Passive Monitoring)이었다. 그러나 다양한 고객들로부터의 피드백을 통해 문제가 감지돼야만 조치할 수 있는 수동적 관찰이 아닌, 능동적 시험(Active Test)도 매우 필요하다는 점이 확인됐다. 지역별, 서비스별 상태를 주기적으로 시험함으로써 문제가 발생하기 전에 능동적으로 대처하는 솔루션이 필요하다는 것이 주된 사항이다.

넷스카우트는 ‘엔지니어스 펄스(nGenius Pulse)’를 통해 저비용으로 모니터링 시스템을 구축할 수 있으며, 사용자 체감 성능에 대한 직관적인 가시성을 제공한다.



## 정규 표현식(Regular Expression)

텍스트 데이터를 전처리하다보면, 정규 표현식은 아주 유용한 도구로서 사용됩니다. 이번 챕터에서는 파이썬에서 지원하고 있는 정규 표현식 모듈 re의 사용 방법과 NLTK를 통한 정규 표현식을 이용한 토큰화에 대해서 알아보도록 하겠습니다.

## **1. 정규 표현식 문법과 모듈 함수**

파이썬에서는 정규 표현식 모듈 re을 지원하므로, 이를 이용하면 특정 규칙이 있는 텍스트 데이터를 빠르게 정제할 수 있습니다. 본격적으로 정규 표현식에 대해서 실습해보기에 앞서 정규 표현식을 위해 사용되는 특수 문자와 모듈 함수에 대해서 알아보도록 하겠습니다.

### **1) 정규 표현식 문법**

정규 표현식을 위해 사용되는 문법 중 특수 문자들은 아래와 같습니다.

| 특수 문자      | 설명                                                         |
| :------------- | :----------------------------------------------------------- |
| .              | 한 개의 임의의 문자를 나타냅니다. (줄바꿈 문자인 \n는 제외)  |
| ?              | 앞의 문자가 존재할 수도 있고, 존재하지 않을 수도 있습니다. (문자가 0개 또는 1개) |
| *              | 앞의 문자가 무한개로 존재할 수도 있고, 존재하지 않을 수도 있습니다. (문자가 0개 이상) |
| +              | 앞의 문자가 최소 한 개 이상 존재합니다. (문자가 1개 이상)    |
| ^              | 뒤의 문자로 문자열이 시작됩니다.                             |
| $              | 앞의 문자로 문자열이 끝납니다.                               |
| {숫자}         | 숫자만큼 반복합니다.                                         |
| {숫자1, 숫자2} | 숫자1 이상 숫자2 이하만큼 반복합니다. ?, *, +를 이것으로 대체할 수 있습니다. |
| {숫자,}        | 숫자 이상만큼 반복합니다.                                    |
| [ ]            | 대괄호 안의 문자들 중 한 개의 문자와 매치합니다. [amk]라고 한다면 a 또는 m 또는 k 중 하나라도 존재하면 매치를 의미합니다. [a-z]와 같이 범위를 지정할 수도 있습니다. [a-zA-Z]는 알파벳 전체를 의미하는 범위이며, 문자열에 알파벳이 존재하면 매치를 의미합니다. |
| [^문자]        | 해당 문자를 제외한 문자를 매치합니다.                        |
| l              | AlB와 같이 쓰이며 A 또는 B의 의미를 가집니다.                |

정규 표현식 문법에는 역 슬래쉬(\)를 이용하여 자주 쓰이는 문자 규칙들이 있습니다.

| 문자 규칙 | 설명                                                         |
| :-------- | :----------------------------------------------------------- |
| \\        | 역 슬래쉬 문자 자체를 의미합니다                             |
| \d        | 모든 숫자를 의미합니다. [0-9]와 의미가 동일합니다.           |
| \D        | 숫자를 제외한 모든 문자를 의미합니다. [^0-9]와 의미가 동일합니다. |
| \s        | 공백을 의미합니다. [ \t\n\r\f\v]와 의미가 동일합니다.        |
| \S        | 공백을 제외한 문자를 의미합니다. [^ \t\n\r\f\v]와 의미가 동일합니다. |
| \w        | 문자 또는 숫자를 의미합니다. [a-zA-Z0-9]와 의미가 동일합니다. |
| \W        | 문자 또는 숫자가 아닌 문자를 의미합니다. [^a-zA-Z0-9]와 의미가 동일합니다. |

### **2) 정규표현식 모듈 함수**

정규표현식 모듈에서 지원하는 함수는 이와 같습니다.

| 모듈 함수     | 설명                                                         |
| :------------ | :----------------------------------------------------------- |
| re.compile()  | 정규표현식을 컴파일하는 함수입니다. 다시 말해, 파이썬에게 전해주는 역할을 합니다. 찾고자 하는 패턴이 빈번한 경우에는 미리 컴파일해놓고 사용하면 속도와 편의성면에서 유리합니다. |
| re.search()   | 문자열 전체에 대해서 정규표현식과 매치되는지를 검색합니다.   |
| re.match()    | 문자열의 처음이 정규표현식과 매치되는지를 검색합니다.        |
| re.split()    | 정규 표현식을 기준으로 문자열을 분리하여 리스트로 리턴합니다. |
| re.findall()  | 문자열에서 정규 표현식과 매치되는 모든 경우의 문자열을 찾아서 리스트로 리턴합니다. 만약, 매치되는 문자열이 없다면 빈 리스트가 리턴됩니다. |
| re.finditer() | 문자열에서 정규 표현식과 매치되는 모든 경우의 문자열에 대한 이터레이터 객체를 리턴합니다. |
| re.sub()      | 문자열에서 정규 표현식과 일치하는 부분에 대해서 다른 문자열로 대체합니다. |

앞으로 진행될 실습에서는 re.compile()에 정규 표현식을 컴파일하고, re.search()를 통해서 해당 정규 표현식이 입력 텍스트와 매치되는지를 확인하면서 각 정규 표현식에 대해서 이해해보도록 하겠습니다. re.search() 함수는 매치된다면 Match Object를 리턴하고, 매치되지 않으면 아무런 값도 출력되지 않습니다.

## **2. 정규 표현식 실습**

앞서 표로 봤던 정규 표현식 특수 문자에 대해서 직접 예제를 통해 이해해보도록 하겠습니다.

### **1) .기호**

.은 한 개의 임의의 문자를 나타냅니다. 예를 들어서 정규 표현식이 a.c라고 합시다. a와 c 사이에는 어떤 1개의 문자라도 올 수 있습니다. 즉, akc, azc, avc, a5c, a!c와 같은 형태는 모두 a.c의 정규 표현식과 매치됩니다. 실제 예제를 통해 이해해보도록 하겠습니다.

```
import re
r=re.compile("a.c")
r.search("kkk") # 아무런 결과도 출력되지 않는다.
r.search("abc")
<_sre.SRE_Match object; span=(0, 3), match='abc'>  
```

위의 코드는 search의 입력으로 들어오는 문자열에 정규표현식 패턴 a.c이 존재하는지를 확인하는 코드입니다. (.)은 어떤 문자로도 인식될 수 있기 때문에 abc라는 문자열은 a.c라는 정규 표현식 패턴으로 매치되는 것을 볼 수 있습니다.

### **2) ?기호**

?는 ? 앞의 문자가 존재할 수도 있고, 존재하지 않을 수도 있는 경우를 나타냅니다. 예를 들어서 정규 표현식이 ab?c라고 합시다. 이 경우 이 정규 표현식에서의 b는 있다고 취급할 수도 있고, 없다고 취급할 수도 있습니다. 즉, abc와 ac 모두 매치할 수 있습니다.

```
import re
r=re.compile("ab?c")
r.search("abbc") # 아무런 결과도 출력되지 않는다.
r.search("abc")
<_sre.SRE_Match object; span=(0, 3), match='abc'>  
```

b가 있는 것으로 판단하여 abc를 매치하는 것을 볼 수 있습니다.

```
r.search("ac")
<_sre.SRE_Match object; span=(0, 2), match='ac'>  
```

b가 없는 것으로 판단하여 ac를 매치하는 것을 볼 수 있습니다.

### **3) \*기호**

*은 바로 앞의 문자가 0개 이상일 경우를 나타냅니다. 앞의 문자는 존재하지 않을 수도 있으며, 또는 여러 개일 수도 있습니다. 예를 들어서 정규 표현식이 abc라고 합시다. 그렇다면 ac, abc, abbc, abbbc 등과 매치할 수 있으며 b의 갯수는 무수히 많아도 상관없습니다.

```
import re
r=re.compile("ab*c")
r.search("a") # 아무런 결과도 출력되지 않는다.
r.search("ac")
<_sre.SRE_Match object; span=(0, 2), match='ac'>  
r.search("abc") 
<_sre.SRE_Match object; span=(0, 3), match='abc'> 
r.search("abbbbc") 
<_sre.SRE_Match object; span=(0, 6), match='abbbbc'> 
```

### **4) +기호**

+는 *와 유사합니다. 하지만 다른 점은 앞의 문자가 최소 1개 이상이어야 한다는 점입니다. 예를 들어서 정규 표현식이 ab+c라고 한다면, ac는 매치되지 않습니다. 하지만 abc, abbc, abbbc 등과 매치할 수 있으며 b의 갯수는 무수히 많을 수 있습니다.

```
import re
r=re.compile("ab+c")
r.search("ac") # 아무런 결과도 출력되지 않는다.
r.search("abc") 
<_sre.SRE_Match object; span=(0, 3), match='abc'>   
r.search("abbbbc") 
<_sre.SRE_Match object; span=(0, 6), match='abbbbc'>  
```

### **5) ^기호**

^는 시작되는 글자를 지정합니다. 가령 정규표현식이 ^a라면 a로 시작되는 문자열만을 찾아냅니다.

```
import re
r=re.compile("^a")
r.search("bbc") # 아무런 결과도 출력되지 않는다.
r.search("ab")                                                                                                    
<_sre.SRE_Match object; span=(0, 1), match='a'>  
```

bbc는 a로 시작되지 않지만, ab는 a로 시작되기 때문에 매치되었습니다.

### **6) {숫자} 기호**

문자에 해당 기호를 붙이면, 해당 문자를 숫자만큼 반복한 것을 나타냅니다. 예를 들어서 정규 표현식이 ab{2}c라면 a와 c 사이에 b가 존재하면서 b가 2개인 문자열에 대해서 매치합니다.

```
import re
r=re.compile("ab{2}c")
r.search("ac") # 아무런 결과도 출력되지 않는다.
r.search("abc") # 아무런 결과도 출력되지 않는다.
r.search("abbc")
<_sre.SRE_Match object; span=(0, 4), match='abbc'>
r.search("abbbbbc") # 아무런 결과도 출력되지 않는다.
```

### **7) {숫자1, 숫자2} 기호**

문자에 해당 기호를 붙이면, 해당 문자를 숫자1 이상 숫자2 이하만큼 반복합니다. 예를 들어서 정규 표현식이 ab{2,8}c라면 a와 c 사이에 b가 존재하면서 b는 2개 이상 8개 이하인 문자열에 대해서 매치합니다.

```
import re
r=re.compile("ab{2,8}c")
r.search("ac") # 아무런 결과도 출력되지 않는다.
r.search("ac") # 아무런 결과도 출력되지 않는다.
r.search("abc") # 아무런 결과도 출력되지 않는다.
r.search("abbc")
<_sre.SRE_Match object; span=(0, 4), match='abbc'>
r.search("abbbbbbbbc")
<_sre.SRE_Match object; span=(0, 10), match='abbbbbbbbc'>
r.search("abbbbbbbbbc") # 아무런 결과도 출력되지 않는다.
```

### **8) {숫자,} 기호**

문자에 해당 기호를 붙이면 해당 문자를 숫자 이상 만큼 반복합니다. 예를 들어서 정규 표현식이 a{2,}bc라면 뒤에 bc가 붙으면서 a의 갯수가 2개 이상인 경우인 문자열과 매치합니다. 또한 만약 {0,}을 쓴다면 *와 동일한 의미가 되며, {1,}을 쓴다면 +와 동일한 의미가 됩니다.

```
import re
r=re.compile("a{2,}bc")
r.search("bc") # 아무런 결과도 출력되지 않는다.
r.search("aa") # 아무런 결과도 출력되지 않는다.
r.search("aabc")
<_sre.SRE_Match object; span=(0, 4), match='aabc'>
r.search("aaaaaaaabc")
<_sre.SRE_Match object; span=(0, 10), match='aaaaaaaabc'> 
```

### **9) [ ] 기호**

[ ]안에 문자들을 넣으면 그 문자들 중 한 개의 문자와 매치라는 의미를 가집니다. 예를 들어서 정규 표현식이 [abc]라면, a 또는 b또는 c가 들어가있는 문자열과 매치됩니다. 범위를 지정하는 것도 가능합니다. [a-zA-Z]는 알파벳 전부를 의미하며, [0-9]는 숫자 전부를 의미합니다.

```
import re
r=re.compile("[abc]") # [abc]는 [a-c]와 같다.
r.search("zzz") # 아무런 결과도 출력되지 않는다.
r.search("a")
<_sre.SRE_Match object; span=(0, 1), match='a'> 
r.search("aaaaaaa")                                                                                               
<_sre.SRE_Match object; span=(0, 1), match='a'> 
r.search("baac")      
<_sre.SRE_Match object; span=(0, 1), match='b'>
```

이번에는 알파벳 소문자에 대해서만 범위 지정하여 정규 표현식을 만들어보고 문자열과 매치해보도록 하겠습니다.

```
import re

r=re.compile("[a-z]")
r.search("AAA") # 아무런 결과도 출력되지 않는다.
r.search("aBC")
<_sre.SRE_Match object; span=(0, 1), match='a'>
r.search("111") # 아무런 결과도 출력되지 않는다.
```

### **10) [^문자] 기호**

[^문자]는 5)에서 설명한 ^와는 완전히 다른 의미로 쓰입니다. 여기서는 ^ 기호 뒤에 붙은 문자들을 제외한 모든 문자를 매치하는 역할을 합니다. 예를 들어서 [^abc]라는 정규 표현식이 있다면, a 또는 b 또는 c가 들어간 문자열을 제외한 모든 문자열을 매치합니다.

```
import re
r=re.compile("[^abc]")
r.search("a") # 아무런 결과도 출력되지 않는다.
r.search("ab") # 아무런 결과도 출력되지 않는다.
r.search("b") # 아무런 결과도 출력되지 않는다.
r.search("d")
<_sre.SRE_Match object; span=(0, 1), match='d'> 
r.search("1")                                                                                                
<_sre.SRE_Match object; span=(0, 1), match='1'> 
```



* 모델 만들기 
* 이분화된 답이 나올수 있게끔 질문
* 결정 트리 구축 원칙

각 노드에서 테스트할 특성 선택

분류시 가장 유용한 특성 순서로 선택

정보획득량 : 각 특성들이 훈련예제들을 얼만큼 잘 분류할수 있는가를 측정

//트리 구축 과정에서 테스트 할 후보 특성의 순서 결정시 사용 

IG를 최대로 얻어낼수 있게금 한다 



- 엔트로피 (복잡도)
-  확률 변수의 불확실성을 수치로 나타냄  // 1이 나온다 => 굉장히 복잡하다



![information gain cartoonì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://t1.daumcdn.net/cfile/tistory/99316B4A5B684E6E23)

(0, 4-) => y

(1, 3-) => y

어질러져 있는 상태 - 가장 효과 큰 청소 항목을 제거해주자 

0.543 : 복잡도 



![information gainì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://i.ytimg.com/vi/2k-ZlWwxoCM/maxresdefault.jpg)

정보 획득량 : 엔트로피 ( 불확실성 ) 의 감소량

서로 다른 데이터가 반반씩 섞여있다 => 